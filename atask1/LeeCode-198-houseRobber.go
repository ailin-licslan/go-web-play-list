package main

/**
198. 打家劫舍：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的
房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非
负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。这道题可以使用动态规划的思想，通过 for 循环遍
历数组，利用 if 条件判断来决定是否选择当前房屋进行抢劫，状态转移方程为 dp[i] = maxOne(dp[i - 1], dp[i - 2] + nums[i])。
*/

// max 定义一个辅助函数，用于返回两个数中的较大值
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// houseRobber函数用于计算在不触动警报装置的情况下能偷窃到的最高金额
func houseRobber(nums []int) int {
	length := len(nums)
	if length == 0 {
		return 0
	}
	if length == 1 {
		return nums[0]
	}
	// 创建一个切片dp用于存储动态规划的结果
	dp := make([]int, length)
	dp[0] = nums[0]
	dp[1] = max(nums[0], nums[1])
	for i := 2; i < length; i++ {
		// 根据状态转移方程更新dp[i]
		dp[i] = max(dp[i-1], dp[i-2]+nums[i])
	}
	return dp[length-1]
}

/**
这是动态规划解决“打家劫舍”问题中状态转移方程的核心部分，下面详细解释一下：
在“打家劫舍”问题中，有一排房屋，每个房屋内都有一定数量的现金。但是相邻的房屋装有相互连通的防盗系统，如果在同一晚上偷了相邻的房屋，系统就会报警。
我们的目标是在不触发警报的情况下，计算能从这些房屋中偷窃到的最高总金额。

动态规划的状态定义
我们定义dp[i]表示考虑前i个房屋（从第0个房屋到第i个房屋 ，索引从0开始）时，能偷窃到的最大金额。

状态转移方程分析
状态转移方程为dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])，下面分别解释选择“不偷第i个房屋”和“偷第i个房屋”时的情况：

1. 不偷第i个房屋时，总金额为dp[i - 1]
当决定不偷第i个房屋时，因为没有对这个房屋进行操作，所以此时能获得的最大金额其实就是考虑前i - 1个房屋时的最大金额，也就是dp[i - 1]。
这是因为我们在计算dp[i - 1]时，已经考虑了前i - 1个房屋的所有可能情况（包括偷与不偷某些房屋 ），得到了在不偷第i个房屋的前提下，能获得的最优解。
例如，假设有房屋A、B、C、D，现在考虑房屋D，如果不偷D，那么此时的最大金额就是在考虑A、B、C这三个房屋时计算出的最大金额dp[3]（假设D是第4个房屋，索引为3 ）。

2. 偷第i个房屋时，总金额为dp[i - 2] + nums[i]
当决定偷第i个房屋时，由于不能偷相邻的房屋，所以我们不能偷第i - 1个房屋。那么在偷第i个房屋的情况下，能获得的最大金额就是在考虑前i - 2个房屋时的最
大金额dp[i - 2]，再加上第i个房屋内的现金数量nums[i]。
继续以上面的例子来说，假设要偷房屋D，因为不能偷相邻的房屋C，所以此时的最大金额就是在考虑房屋A、B时计算出的最大金额dp[2]
（假设C是第3个房屋，索引为2 ），再加上房屋D内的现金数量nums[3]。

综合选择
最后，我们通过max(dp[i - 1], dp[i - 2] + nums[i])来选择这两种情况中的较大值作为dp[i]，即要么不偷第i个房屋，要么偷第i个房屋，取这两种选择中
能获得的最大金额作为考虑前i个房屋时的最优解。
通过这样不断地更新dp数组，从前面的子问题逐步推导出后面的子问题的解，最终dp数组的最后一个元素就表示考虑了所有房屋后能偷窃到的最大金额。

*/
